{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "jHLGVoh8NJLK"
   },
   "source": [
    "**Programa para el env√≠o masivo de recibos de mantenimiento por correo**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 12596,
     "status": "ok",
     "timestamp": 1760076428577,
     "user": {
      "displayName": "Mirador Venezuela",
      "userId": "17997044465119919784"
     },
     "user_tz": 300
    },
    "id": "zRbRRJB5Hggm",
    "outputId": "8c029525-bc97-43a6-fa13-8ebb1ac9cf2b"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Requirement already satisfied: PyPDF2 in /usr/local/lib/python3.12/dist-packages (3.0.1)\n",
      "Requirement already satisfied: pandas in /usr/local/lib/python3.12/dist-packages (2.2.2)\n",
      "Requirement already satisfied: numpy>=1.26.0 in /usr/local/lib/python3.12/dist-packages (from pandas) (2.0.2)\n",
      "Requirement already satisfied: python-dateutil>=2.8.2 in /usr/local/lib/python3.12/dist-packages (from pandas) (2.9.0.post0)\n",
      "Requirement already satisfied: pytz>=2020.1 in /usr/local/lib/python3.12/dist-packages (from pandas) (2025.2)\n",
      "Requirement already satisfied: tzdata>=2022.7 in /usr/local/lib/python3.12/dist-packages (from pandas) (2025.2)\n",
      "Requirement already satisfied: six>=1.5 in /usr/local/lib/python3.12/dist-packages (from python-dateutil>=2.8.2->pandas) (1.17.0)\n",
      "Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n"
     ]
    }
   ],
   "source": [
    "!pip install PyPDF2 pandas\n",
    "import os\n",
    "import re\n",
    "import pandas as pd\n",
    "from PyPDF2 import PdfReader, PdfWriter\n",
    "from google.colab import drive\n",
    "from datetime import datetime\n",
    "import time\n",
    "import smtplib\n",
    "from email.mime.multipart import MIMEMultipart\n",
    "from email.mime.text import MIMEText\n",
    "from email.mime.application import MIMEApplication\n",
    "from email.utils import formatdate\n",
    "import traceback\n",
    "\n",
    "# Montar Google Drive\n",
    "drive.mount('/content/drive')\n",
    "base_path = '/content/drive/MyDrive/Condominio El Mirador I/RECIBOS 2025/Programa de env√≠o masivo de correos' #Tu ruta\n",
    "\n",
    "# Crear carpetas base si no existen\n",
    "os.makedirs(f'{base_path}/Recibos_Origen', exist_ok=True)\n",
    "os.makedirs(f'{base_path}/Recibos_Individuales', exist_ok=True)\n",
    "os.makedirs(f'{base_path}/Base_Datos', exist_ok=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 7909,
     "status": "ok",
     "timestamp": 1760076449277,
     "user": {
      "displayName": "Mirador Venezuela",
      "userId": "17997044465119919784"
     },
     "user_tz": 300
    },
    "id": "oz6T6Zc9h0mV",
    "outputId": "9d88ea7e-8fa6-4e56-c375-2150ded297dd"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "üü¢ BLOQUE 1: Configuraci√≥n inicial\n",
      "Ingrese el mes (ej: Julio): Septiembre\n",
      "Ingrese el a√±o (ej: 2025): 2025\n",
      "‚úÖ Periodo configurado: Septiembre 2025\n",
      "üìÅ Carpeta creada: /content/drive/MyDrive/Condominio El Mirador I/RECIBOS 2025/Programa de env√≠o masivo de correos/Recibos_Individuales/Septiembre_2025/\n"
     ]
    }
   ],
   "source": [
    "# BLOQUE 1: CONFIGURACI√ìN INICIAL\n",
    "# ============================================\n",
    "print(\"üü¢ BLOQUE 1: Configuraci√≥n inicial\")\n",
    "mes = input(\"Ingrese el mes (ej: Julio): \").strip().capitalize()\n",
    "a√±o = input(\"Ingrese el a√±o (ej: 2025): \").strip()\n",
    "periodo = f\"{mes}_{a√±o}\"\n",
    "\n",
    "# Crear carpeta para el periodo\n",
    "periodo_folder = f'{base_path}/Recibos_Individuales/{periodo}/'\n",
    "os.makedirs(periodo_folder, exist_ok=True)\n",
    "print(f\"‚úÖ Periodo configurado: {mes} {a√±o}\")\n",
    "print(f\"üìÅ Carpeta creada: {periodo_folder}\")\n",
    "\n",
    "# Ruta del archivo Excel\n",
    "db_path = f'{base_path}/Base_Datos/base_datos.xlsx'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 6678,
     "status": "ok",
     "timestamp": 1760076484614,
     "user": {
      "displayName": "Mirador Venezuela",
      "userId": "17997044465119919784"
     },
     "user_tz": 300
    },
    "id": "SiMfcZj6jQTK",
    "outputId": "27096da8-555e-47a2-f469-5609909ec124"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "üü¢ BLOQUE 2: Extraer recibos individuales\n",
      "üìÑ Procesando archivo: SETIEMBRE 2025.xlsx - RECIBOS.pdf\n",
      "üî¢ Total de p√°ginas: 126\n",
      "‚úÖ 101A ‚úÖ 503A ‚úÖ 903A ‚úÖ 1303A ‚úÖ 303B ‚úÖ 703B ‚úÖ 1103B ‚úÖ 102A ‚úÖ 504A ‚úÖ 904A ‚úÖ 1304A ‚úÖ 304B ‚úÖ 704B ‚úÖ 1104B ‚úÖ 201A ‚úÖ 601A ‚úÖ 1001A ‚úÖ 1401A ‚úÖ 401B ‚úÖ 801B ‚úÖ 1201B ‚úÖ 202A ‚úÖ 602A ‚úÖ 1002A ‚úÖ 1402A ‚úÖ 402B ‚úÖ 802B ‚úÖ 1202B ‚úÖ 203A ‚úÖ 603A ‚úÖ 1003A ‚úÖ 1403A ‚úÖ 403B ‚úÖ 803B ‚úÖ 1203B ‚úÖ 204A ‚úÖ 604A ‚úÖ 1004A ‚úÖ 1404A ‚úÖ 404B ‚úÖ 804B ‚úÖ 1204B ‚úÖ 301A ‚úÖ 701A ‚úÖ 1101A ‚úÖ 101B ‚úÖ 501B ‚úÖ 901B ‚úÖ 1301B ‚úÖ 302A ‚úÖ 702A ‚úÖ 1102A ‚úÖ 102B ‚úÖ 502B ‚úÖ 902B ‚úÖ 1302B ‚úÖ 303A ‚úÖ 703A ‚úÖ 1103A ‚úÖ 103B ‚úÖ 503B ‚úÖ 903B ‚úÖ 1303B ‚úÖ 304A ‚úÖ 704A ‚úÖ 1104A ‚úÖ 104B ‚úÖ 504B ‚úÖ 904B ‚úÖ 1304B ‚úÖ 401A ‚úÖ 801A ‚úÖ 1201A ‚úÖ 201B ‚úÖ 601B ‚úÖ 1001B ‚úÖ 1401B ‚úÖ 402A ‚úÖ 802A ‚úÖ 1202A ‚úÖ 202B ‚úÖ 602B ‚úÖ 1002B ‚úÖ 1402B ‚úÖ 403A ‚úÖ 803A ‚úÖ 1203A ‚úÖ 203B ‚úÖ 603B ‚úÖ 1003B ‚úÖ 1403B ‚úÖ 404A ‚úÖ 804A ‚úÖ 1204A ‚úÖ 204B ‚úÖ 604B ‚úÖ 1004B ‚úÖ 1404B ‚úÖ 501A ‚úÖ 901A "
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-11368684') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-9094947') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-9094947') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-11368684') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-11368684') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-9094947') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-11368684') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-11368684') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-9094947') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-9094947') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-11368684') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-11368684') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-9094947') invalid; use 0.0 instead\n",
      "WARNING:PyPDF2.generic._base:FloatObject (b'0.00000000000-9094947') invalid; use 0.0 instead\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "‚úÖ 1301A ‚úÖ 301B ‚úÖ 701B ‚úÖ 1101B ‚úÖ 502A ‚úÖ 902A ‚úÖ 1302A ‚úÖ 302B ‚úÖ 702B ‚úÖ 1102B \n",
      "\n",
      "üìÅ Total departamentos procesados: 110\n",
      "üìç Recibos guardados en: /content/drive/MyDrive/Condominio El Mirador I/RECIBOS 2025/Programa de env√≠o masivo de correos/Recibos_Individuales/Septiembre_2025/\n"
     ]
    }
   ],
   "source": [
    "# ============================================\n",
    "# BLOQUE 2: EXTRAER RECIBOS INDIVIDUALES\n",
    "# ============================================\n",
    "print(\"\\nüü¢ BLOQUE 2: Extraer recibos individuales\")\n",
    "\n",
    "# Buscar archivo PDF en Recibos_Origen\n",
    "pdf_files = [f for f in os.listdir(f'{base_path}/Recibos_Origen') if f.lower().endswith('.pdf')]\n",
    "if not pdf_files:\n",
    "    print(\"‚ö†Ô∏è Error: No se encontraron archivos PDF en Recibos_Origen\")\n",
    "    print(\"Por favor sube el archivo PDF y vuelve a ejecutar este bloque\")\n",
    "else:\n",
    "    input_pdf = f'{base_path}/Recibos_Origen/{pdf_files[0]}'\n",
    "    print(f\"üìÑ Procesando archivo: {pdf_files[0]}\")\n",
    "\n",
    "    with open(input_pdf, 'rb') as file:\n",
    "        reader = PdfReader(file)\n",
    "        total_pages = len(reader.pages)\n",
    "        print(f\"üî¢ Total de p√°ginas: {total_pages}\")\n",
    "\n",
    "        departamentos_procesados = []\n",
    "\n",
    "        for page_num in range(total_pages):\n",
    "            page = reader.pages[page_num]\n",
    "            text = page.extract_text()\n",
    "\n",
    "            # Buscar patr√≥n de departamento (ej: 701B)\n",
    "            dpto_match = re.search(r'(\\d+[AB])\\s*$', text, re.MULTILINE)\n",
    "\n",
    "            if dpto_match:\n",
    "                dpto = dpto_match.group(1)\n",
    "                writer = PdfWriter()\n",
    "                writer.add_page(page)\n",
    "\n",
    "                # Guardar como PDF individual\n",
    "                output_pdf = f'{periodo_folder}{dpto}.pdf'\n",
    "                with open(output_pdf, 'wb') as output_file:\n",
    "                    writer.write(output_file)\n",
    "\n",
    "                departamentos_procesados.append(dpto)\n",
    "                print(f\"‚úÖ {dpto}\", end=' ', flush=True)\n",
    "\n",
    "        print(f\"\\n\\nüìÅ Total departamentos procesados: {len(departamentos_procesados)}\")\n",
    "        print(f\"üìç Recibos guardados en: {periodo_folder}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 404,
     "status": "ok",
     "timestamp": 1760076568701,
     "user": {
      "displayName": "Mirador Venezuela",
      "userId": "17997044465119919784"
     },
     "user_tz": 300
    },
    "id": "26Z7OkVrjVHp",
    "outputId": "92291848-0435-46b9-e67f-ff541ab8f59a"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "üü¢ BLOQUE 3: Verificar base de datos\n",
      "üîç Base de datos existente cargada\n",
      "Columnas detectadas: ['DPTO', 'NOMBRES Y APELLIDOS', 'DOCUMENTO DE IDENTIDAD', 'CORREO_1', 'CELULAR_1', 'CORREO_2', 'CELULAR_2', 'COCHERA', 'MASCOTAS', 'OBSERVACION', 'NOMBRE_ARCHIVO']\n",
      "‚Ü™Ô∏è Columnas renombradas: {'DPTO': 'Departamento', 'NOMBRES Y APELLIDOS': 'Propietario', 'CORREO_1': 'Email', 'CORREO_2': 'Email_CC', 'NOMBRE_ARCHIVO': 'Archivo_PDF'}\n",
      "\n",
      "üìä Vista previa de la base de datos (primeras 5 filas):\n",
      "Departamento                      Propietario DOCUMENTO DE IDENTIDAD                    Email   CELULAR_1 Email_CC   CELULAR_2 COCHERA MASCOTAS OBSERVACION Archivo_PDF\n",
      "        101A MIRTHA RAFAELA VILCABANA OCHANTE               43368397                      NaN   924309163      NaN         NaN     NaN      NaN         NaN    101A.pdf\n",
      "        102A     MIRTA JESSICA MONROY CARNERO               74648205                      NaN 987 751 256      NaN 982313748.0     NaN      NaN         NaN    102A.pdf\n",
      "        201A        JESSICA ALTAMIRANO AG√úERO               40697400    jennysentir@gmail.com   999905726      NaN         NaN     NaN       No         NaN    201A.pdf\n",
      "        202A      LUISA CRISTINA NARVAEZ ANZA                    NaN kelly.canturin@gmail.com         NaN      NaN 993600551.0     NaN      NaN         NaN    202A.pdf\n",
      "        203A      JULIO CESAR CABRERA DELGADO               09916885                      NaN   914397416      NaN 994230624.0     NaN      NaN         NaN    203A.pdf\n",
      "\n",
      "üîç Verificaci√≥n de datos:\n",
      "- Total registros: 110\n",
      "- Emails no vac√≠os: 102\n",
      "- Archivos PDF asignados: 110\n"
     ]
    }
   ],
   "source": [
    "# ============================================\n",
    "# BLOQUE 3: VERIFICAR BASE DE DATOS\n",
    "# ============================================\n",
    "print(\"\\nüü¢ BLOQUE 3: Verificar base de datos\")\n",
    "\n",
    "# Cargar base de datos\n",
    "if os.path.exists(db_path):\n",
    "    try:\n",
    "        # Leer Excel con encabezado en la primera fila\n",
    "        df = pd.read_excel(db_path)\n",
    "        print(\"üîç Base de datos existente cargada\")\n",
    "\n",
    "        # Verificar estructura\n",
    "        print(\"Columnas detectadas:\", df.columns.tolist())\n",
    "\n",
    "        # Renombrar columnas a nombres estandarizados\n",
    "        rename_map = {}\n",
    "        column_mapping = {\n",
    "            'DPTO': 'Departamento',\n",
    "            'NOMBRES Y APELLIDOS': 'Propietario',\n",
    "            'CORREO_1': 'Email',\n",
    "            'CORREO_2': 'Email_CC',\n",
    "            'NOMBRE_ARCHIVO': 'Archivo_PDF'\n",
    "        }\n",
    "\n",
    "        for original, nuevo in column_mapping.items():\n",
    "            if original in df.columns:\n",
    "                rename_map[original] = nuevo\n",
    "\n",
    "        if rename_map:\n",
    "            df = df.rename(columns=rename_map)\n",
    "            print(f\"‚Ü™Ô∏è Columnas renombradas: {rename_map}\")\n",
    "\n",
    "        # Verificar si existen todas las columnas necesarias\n",
    "        required_columns = ['Departamento', 'Propietario', 'Email', 'Archivo_PDF']\n",
    "        missing_cols = [col for col in required_columns if col not in df.columns]\n",
    "\n",
    "        if missing_cols:\n",
    "            print(f\"‚ö†Ô∏è Advertencia: Faltan columnas: {', '.join(missing_cols)}\")\n",
    "\n",
    "            # A√±adir columnas faltantes\n",
    "            for col in missing_cols:\n",
    "                if col not in df.columns:\n",
    "                    df[col] = ''\n",
    "                    print(f\"‚ûï Columna '{col}' a√±adida\")\n",
    "    except Exception as e:\n",
    "        print(f\"‚ùå Error al cargar la base de datos: {str(e)}\")\n",
    "        exit()\n",
    "else:\n",
    "    print(\"‚ùå Error: No se encontr√≥ la base de datos\")\n",
    "    exit()\n",
    "\n",
    "# Mostrar vista previa detallada\n",
    "print(\"\\nüìä Vista previa de la base de datos (primeras 5 filas):\")\n",
    "print(df.head().to_string(index=False))\n",
    "\n",
    "print(\"\\nüîç Verificaci√≥n de datos:\")\n",
    "print(f\"- Total registros: {len(df)}\")\n",
    "print(f\"- Emails no vac√≠os: {df['Email'].notna().sum()}\")\n",
    "print(f\"- Archivos PDF asignados: {df['Archivo_PDF'].notna().sum()}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 1000
    },
    "executionInfo": {
     "elapsed": 70896,
     "status": "error",
     "timestamp": 1760076746637,
     "user": {
      "displayName": "Mirador Venezuela",
      "userId": "17997044465119919784"
     },
     "user_tz": 300
    },
    "id": "3dnm9Wx2jYst",
    "outputId": "db36a168-1d5c-4385-8ba1-7f0492e11856"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "üü¢ BLOQUE 4: Enviar correos\n",
      "\n",
      "üßπ Realizando limpieza de datos...\n",
      "\n",
      "üìä RESUMEN DE DATOS:\n",
      "üìã Total registros: 110\n",
      "‚úâÔ∏è  Correos v√°lidos: 102\n",
      "‚ö†Ô∏è  Correos inv√°lidos: 8\n",
      "\n",
      "‚úÖ Primeros 5 correos v√°lidos:\n",
      "Departamento                    Propietario                    Email               Email_CC\n",
      "        201A      JESSICA ALTAMIRANO AG√úERO    jennysentir@gmail.com                       \n",
      "        202A    LUISA CRISTINA NARVAEZ ANZA kelly.canturin@gmail.com                       \n",
      "        204A       YVAN LUIS SAYBAY COTRINA       ylsaybay@gmail.com                       \n",
      "        301A   ROSANA MARIA ROMERO PINILLOS      tanarp1@hotmail.com                       \n",
      "        302A SILVIA DEL ROSARIO AVALOS TASA  silvia.1706@hotmail.com Vivilorena93@gmail.com\n",
      "üìã Rango de departamentos: 201A a 1404B\n",
      "Ingrese el departamento desde el cual comenzar el env√≠o\n",
      "(ejemplo: 101A para empezar desde el inicio, o 601A para continuar): 601A\n",
      "‚úÖ Departamento encontrado: 601A\n",
      "\n",
      "üöÄ INICIANDO ENV√çO DESDE: 601A\n",
      "üìß Total de correos a enviar: 87\n",
      "\n",
      "üìã Primeros 3 departamentos en la cola de env√≠o:\n",
      "   1. 601A - FELIPE JARAMILLO CAPITAN\n",
      "   2. 602A - H√âCTOR RODOLFO CARRI√ìN RIVEROS\n",
      "   3. 603A - CESAR ALTAMIRANO GUEVARA\n",
      "\n",
      "üîê CONFIGURACI√ìN SMTP\n",
      "\n",
      "üîå CONECTANDO CON SERVIDOR SMTP...\n",
      "üîë AUTENTICACI√ìN EXITOSA\n",
      "\n",
      "‚úâÔ∏è INICIANDO ENV√çO DE 87 CORREOS...\n",
      "‚è±Ô∏è Pausa entre env√≠os: 15 segundos\n",
      "\n",
      "‚û°Ô∏è [16/87] Enviando a FELIPE JARAMILLO CAPITAN <yvargasp1@gmail.com>\n",
      "üìé Adjunto: 601A.pdf\n",
      "‚úÖ ENVIADO (Intento 1/3)\n",
      "üì¨ Destinatarios enviados: 1/500\n",
      "‚è≥ Esperando 15 segundos antes del pr√≥ximo env√≠o...\n",
      "\n",
      "‚û°Ô∏è [17/87] Enviando a H√âCTOR RODOLFO CARRI√ìN RIVEROS <hecamore@hotmail.com>\n",
      "üìé Adjunto: 602A.pdf\n",
      "‚úÖ ENVIADO (Intento 1/3)\n",
      "üì¨ Destinatarios enviados: 2/500\n",
      "‚è≥ Esperando 15 segundos antes del pr√≥ximo env√≠o...\n",
      "üîí CONEXI√ìN SMTP CERRADA\n"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m/tmp/ipython-input-17117380.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m    306\u001b[0m             \u001b[0;31m# Pausa para evitar sobrecarga\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    307\u001b[0m             \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34mf\"‚è≥ Esperando {pausa_entre_envios} segundos antes del pr√≥ximo env√≠o...\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 308\u001b[0;31m             \u001b[0mtime\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msleep\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpausa_entre_envios\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    309\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    310\u001b[0m         \u001b[0;32mexcept\u001b[0m \u001b[0msmtplib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mSMTPDataError\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "# ============================================\n",
    "# BLOQUE 4: ENVIAR CORREOS\n",
    "# ============================================\n",
    "print(\"\\nüü¢ BLOQUE 4: Enviar correos\")\n",
    "\n",
    "# Funci√≥n para ordenar departamentos en el orden espec√≠fico\n",
    "def ordenar_departamentos(df):\n",
    "    # Definir el orden exacto de los departamentos\n",
    "    orden_especifico = [\n",
    "        '101A', '102A', '201A', '202A', '203A', '204A', '301A', '302A', '303A', '304A',\n",
    "        '401A', '402A', '403A', '404A', '501A', '502A', '503A', '504A', '601A', '602A',\n",
    "        '603A', '604A', '701A', '702A', '703A', '704A', '801A', '802A', '803A', '804A',\n",
    "        '901A', '902A', '903A', '904A', '1001A', '1002A', '1003A', '1004A', '1101A', '1102A',\n",
    "        '1103A', '1104A', '1201A', '1202A', '1203A', '1204A', '1301A', '1302A', '1303A', '1304A',\n",
    "        '1401A', '1402A', '1403A', '1404A', '101B', '102B', '103B', '104B', '201B', '202B',\n",
    "        '203B', '204B', '301B', '302B', '303B', '304B', '401B', '402B', '403B', '404B',\n",
    "        '501B', '502B', '503B', '504B', '601B', '602B', '603B', '604B', '701B', '702B',\n",
    "        '703B', '704B', '801B', '802B', '803B', '804B', '901B', '902B', '903B', '904B',\n",
    "        '1001B', '1002B', '1003B', '1004B', '1101B', '1102B', '1103B', '1104B', '1201B', '1202B',\n",
    "        '1203B', '1204B', '1301B', '1302B', '1303B', '1304B', '1401B', '1402B', '1403B', '1404B'\n",
    "    ]\n",
    "\n",
    "    # Crear un diccionario de mapeo de departamento a posici√≥n\n",
    "    orden_map = {depto: idx for idx, depto in enumerate(orden_especifico)}\n",
    "\n",
    "    # Filtrar solo los departamentos que existen en el DataFrame\n",
    "    df['Departamento'] = df['Departamento'].str.strip().str.upper()\n",
    "    departamentos_existentes = df['Departamento'].unique()\n",
    "\n",
    "    # Ordenar el DataFrame seg√∫n el orden espec√≠fico\n",
    "    df['orden'] = df['Departamento'].map(orden_map)\n",
    "    df = df.sort_values('orden').drop('orden', axis=1).reset_index(drop=True)\n",
    "\n",
    "    return df\n",
    "\n",
    "# Funci√≥n para seleccionar el departamento\n",
    "def seleccionar_departamento(df_validos):\n",
    "    # Ordenar el DataFrame seg√∫n el orden espec√≠fico\n",
    "    df_work = ordenar_departamentos(df_validos)\n",
    "\n",
    "    # Mostrar el primer y √∫ltimo departamento disponible como referencia\n",
    "    primer_depto = df_work.iloc[0]['Departamento']\n",
    "    ultimo_depto = df_work.iloc[-1]['Departamento']\n",
    "\n",
    "    print(f\"üìã Rango de departamentos: {primer_depto} a {ultimo_depto}\")\n",
    "\n",
    "    while True:\n",
    "        # Pedir al usuario que ingrese el departamento de inicio\n",
    "        departamento = input(\n",
    "            \"Ingrese el departamento desde el cual comenzar el env√≠o\\n\"\n",
    "            \"(ejemplo: 101A para empezar desde el inicio, o 601A para continuar): \"\n",
    "        ).strip().upper()\n",
    "\n",
    "        # Si est√° vac√≠o, usar el primer departamento\n",
    "        if not departamento:\n",
    "            print(f\"‚úÖ Comenzando desde el primer departamento: {primer_depto}\")\n",
    "            return df_work\n",
    "\n",
    "        # Buscar el departamento exacto\n",
    "        if departamento in df_work['Departamento'].values:\n",
    "            print(f\"‚úÖ Departamento encontrado: {departamento}\")\n",
    "            # Encontrar el √≠ndice del departamento\n",
    "            index_departamento = df_work[df_work['Departamento'] == departamento].index[0]\n",
    "            return df_work.iloc[index_departamento:]\n",
    "\n",
    "        # Si no existe, buscar el siguiente disponible autom√°ticamente\n",
    "        print(f\"‚ö†Ô∏è El departamento '{departamento}' no se encuentra.\")\n",
    "        print(\"üîç Buscando el siguiente departamento disponible...\")\n",
    "\n",
    "        # Buscar en el orden espec√≠fico\n",
    "        orden_especifico = [\n",
    "            '101A', '102A', '201A', '202A', '203A', '204A', '301A', '302A', '303A', '304A',\n",
    "            '401A', '402A', '403A', '404A', '501A', '502A', '503A', '504A', '601A', '602A',\n",
    "            '603A', '604A', '701A', '702A', '703A', '704A', '801A', '802A', '803A', '804A',\n",
    "            '901A', '902A', '903A', '904A', '1001A', '1002A', '1003A', '1004A', '1101A', '1102A',\n",
    "            '1103A', '1104A', '1201A', '1202A', '1203A', '1204A', '1301A', '1302A', '1303A', '1304A',\n",
    "            '1401A', '1402A', '1403A', '1404A', '101B', '102B', '103B', '104B', '201B', '202B',\n",
    "            '203B', '204B', '301B', '302B', '303B', '304B', '401B', '402B', '403B', '404B',\n",
    "            '501B', '502B', '503B', '504B', '601B', '602B', '603B', '604B', '701B', '702B',\n",
    "            '703B', '704B', '801B', '802B', '803B', '804B', '901B', '902B', '903B', '904B',\n",
    "            '1001B', '1002B', '1003B', '1004B', '1101B', '1102B', '1103B', '1104B', '1201B', '1202B',\n",
    "            '1203B', '1204B', '1301B', '1302B', '1303B', '1304B', '1401B', '1402B', '1403B', '1404B'\n",
    "        ]\n",
    "\n",
    "        # Encontrar la posici√≥n del departamento en el orden espec√≠fico\n",
    "        try:\n",
    "            pos_ingresado = orden_especifico.index(departamento)\n",
    "        except ValueError:\n",
    "            # Si no est√° en la lista, encontrar el primer departamento mayor\n",
    "            pos_ingresado = -1\n",
    "\n",
    "        # Buscar el siguiente departamento disponible\n",
    "        siguiente_depto = None\n",
    "        if pos_ingresado >= 0:\n",
    "            # Buscar desde la posici√≥n siguiente\n",
    "            for depto in orden_especifico[pos_ingresado + 1:]:\n",
    "                if depto in df_work['Departamento'].values:\n",
    "                    siguiente_depto = depto\n",
    "                    break\n",
    "        else:\n",
    "            # Buscar el primer departamento mayor al ingresado\n",
    "            for depto in orden_especifico:\n",
    "                if depto > departamento and depto in df_work['Departamento'].values:\n",
    "                    siguiente_depto = depto\n",
    "                    break\n",
    "\n",
    "        if siguiente_depto:\n",
    "            print(f\"‚úÖ Continuando desde: {siguiente_depto}\")\n",
    "            index_departamento = df_work[df_work['Departamento'] == siguiente_depto].index[0]\n",
    "            return df_work.iloc[index_departamento:]\n",
    "        else:\n",
    "            # Si no hay departamentos mayores, mostrar mensaje\n",
    "            print(f\"‚ùå No hay departamentos despu√©s de '{departamento}'\")\n",
    "            print(\"üí° Por favor ingrese un departamento v√°lido del rango mostrado.\")\n",
    "\n",
    "# Limpiar y validar emails\n",
    "print(\"\\nüßπ Realizando limpieza de datos...\")\n",
    "df['Email'] = df['Email'].fillna('').astype(str).str.strip()\n",
    "df['Propietario'] = df['Propietario'].fillna('').astype(str).str.strip()\n",
    "df['Email_CC'] = df.get('Email_CC', '').fillna('').astype(str).str.strip()\n",
    "\n",
    "# Filtrar registros con email v√°lido\n",
    "email_mask = (df['Email'] != '') & (df['Email'].str.contains('@', na=False))\n",
    "df_validos = df[email_mask].copy()\n",
    "emails_invalidos = df[~email_mask]\n",
    "\n",
    "# Imprimir resumen de los datos\n",
    "print(\"\\nüìä RESUMEN DE DATOS:\")\n",
    "print(f\"üìã Total registros: {len(df)}\")\n",
    "print(f\"‚úâÔ∏è  Correos v√°lidos: {len(df_validos)}\")\n",
    "print(f\"‚ö†Ô∏è  Correos inv√°lidos: {len(emails_invalidos)}\")\n",
    "\n",
    "# Mostrar primeros 5 correos v√°lidos para verificaci√≥n\n",
    "if not df_validos.empty:\n",
    "    print(\"\\n‚úÖ Primeros 5 correos v√°lidos:\")\n",
    "    print(df_validos[['Departamento', 'Propietario', 'Email', 'Email_CC']].head().to_string(index=False))\n",
    "\n",
    "if df_validos.empty:\n",
    "    print(\"\\n‚ùå ERROR: No hay registros con email v√°lido\")\n",
    "    exit()\n",
    "\n",
    "# Seleccionar departamento de inicio\n",
    "df_departamento = seleccionar_departamento(df_validos)\n",
    "\n",
    "if df_departamento is not None and not df_departamento.empty:\n",
    "    primer_depto_envio = df_departamento.iloc[0]['Departamento']\n",
    "    print(f\"\\nüöÄ INICIANDO ENV√çO DESDE: {primer_depto_envio}\")\n",
    "    print(f\"üìß Total de correos a enviar: {len(df_departamento)}\")\n",
    "\n",
    "    # Mostrar los primeros 3 departamentos que se enviar√°n\n",
    "    print(\"\\nüìã Primeros 3 departamentos en la cola de env√≠o:\")\n",
    "    for i in range(min(3, len(df_departamento))):\n",
    "        depto = df_departamento.iloc[i]['Departamento']\n",
    "        propietario = df_departamento.iloc[i]['Propietario']\n",
    "        print(f\"   {i+1}. {depto} - {propietario}\")\n",
    "else:\n",
    "    print(\"\\n‚ùå No se pudo determinar desde qu√© departamento comenzar\")\n",
    "    exit()\n",
    "\n",
    "# =============================================================================\n",
    "# CONFIGURACI√ìN Y ENV√çO DE CORREOS\n",
    "# =============================================================================\n",
    "\n",
    "# Configuraci√≥n SMTP\n",
    "print(\"\\nüîê CONFIGURACI√ìN SMTP\")\n",
    "remitente = #direcci√≥n de correo\n",
    "password =  # Contrase√±a de aplicaci√≥n\n",
    "asunto = f'Recibo de Mantenimiento - {mes} {a√±o}'\n",
    "\n",
    "# L√≠mites y temporizador\n",
    "limite_destinatarios = 500  # L√≠mite diario de Gmail\n",
    "pausa_entre_envios = 15  # Segundos entre env√≠os\n",
    "destinatarios_enviados = 0  # Contador de destinatarios\n",
    "\n",
    "# Estad√≠sticas de env√≠o\n",
    "exitosos = 0\n",
    "fallidos = 0\n",
    "errores_archivos = 0\n",
    "errores_envio = 0\n",
    "\n",
    "try:\n",
    "    print(\"\\nüîå CONECTANDO CON SERVIDOR SMTP...\")\n",
    "    server = smtplib.SMTP('smtp.gmail.com', 587, timeout=30)\n",
    "    server.starttls()\n",
    "    server.login(remitente, password)\n",
    "    print(\"üîë AUTENTICACI√ìN EXITOSA\")\n",
    "\n",
    "    total = len(df_departamento)\n",
    "    print(f\"\\n‚úâÔ∏è INICIANDO ENV√çO DE {total} CORREOS...\")\n",
    "    print(f\"‚è±Ô∏è Pausa entre env√≠os: {pausa_entre_envios} segundos\")\n",
    "\n",
    "    for index, row in df_departamento.iterrows():\n",
    "        dpto = row['Departamento']\n",
    "        propietario = row['Propietario'] or 'propietario'\n",
    "        email = row['Email']\n",
    "        email_cc = row.get('Email_CC', '')\n",
    "        archivo_pdf = row['Archivo_PDF']\n",
    "        pdf_path = f\"{periodo_folder}{archivo_pdf}\"\n",
    "\n",
    "        print(f\"\\n‚û°Ô∏è [{index+1}/{total}] Enviando a {propietario} <{email}>\")\n",
    "        if email_cc:\n",
    "            print(f\"   üì© CC: {email_cc}\")\n",
    "\n",
    "        try:\n",
    "            # Crear mensaje\n",
    "            msg = MIMEMultipart()\n",
    "            msg['From'] = remitente\n",
    "            msg['To'] = email\n",
    "\n",
    "            # A√±adir CC si existe\n",
    "            if email_cc:\n",
    "                msg['Cc'] = email_cc\n",
    "\n",
    "            msg['Subject'] = asunto\n",
    "            msg['Date'] = formatdate(localtime=True)\n",
    "\n",
    "            # Cuerpo personalizado\n",
    "            cuerpo = f\"\"\"\n",
    "            Estimado(a) {propietario},\n",
    "\n",
    "            Adjunto encontrar√° el recibo de mantenimiento correspondiente a su departamento {dpto}.\n",
    "\n",
    "            Periodo: {mes} {a√±o}\n",
    "            Fecha de vencimiento: 15 de {mes} (tener en cuenta que, posterior a la fecha, se carga una mora de 15 soles)\n",
    "\n",
    "            Saludos cordiales,\n",
    "            Administraci√≥n del Condominio\n",
    "            \"\"\"\n",
    "            msg.attach(MIMEText(cuerpo, 'plain'))\n",
    "\n",
    "            # Verificar y adjuntar PDF\n",
    "            if os.path.exists(pdf_path):\n",
    "                with open(pdf_path, 'rb') as f:\n",
    "                    part = MIMEApplication(f.read(), Name=archivo_pdf)\n",
    "\n",
    "                part.add_header('Content-Disposition', 'attachment',\n",
    "                               filename=f\"Recibo_{dpto}_{mes}_{a√±o}.pdf\")\n",
    "                msg.attach(part)\n",
    "                print(f\"üìé Adjunto: {archivo_pdf}\")\n",
    "            else:\n",
    "                errores_archivos += 1\n",
    "                print(f\"‚ùå ARCHIVO NO ENCONTRADO: {pdf_path}\")\n",
    "                print(\"‚ö†Ô∏è Enviando correo sin adjunto...\")\n",
    "\n",
    "            # Preparar lista de destinatarios (incluyendo CC)\n",
    "            destinatarios = [email]\n",
    "            if email_cc:\n",
    "                # Manejar m√∫ltiples correos en CC (separados por coma o punto y coma)\n",
    "                cc_list = [e.strip() for e in re.split(r'[;,]\\s*', email_cc) if e.strip()]\n",
    "                destinatarios.extend(cc_list)\n",
    "\n",
    "            # Contar destinatarios\n",
    "            total_destinatarios = len(destinatarios)\n",
    "            destinatarios_enviados += total_destinatarios\n",
    "\n",
    "            # Verificar l√≠mite diario\n",
    "            if destinatarios_enviados > limite_destinatarios:\n",
    "                print(f\"‚õî L√çMITE DIARIO EXCEDIDO: {destinatarios_enviados}/{limite_destinatarios} destinatarios\")\n",
    "                print(\"üí° Soluciones:\")\n",
    "                print(\"- Espera 24 horas para que se reinicie tu cuota\")\n",
    "                print(\"- Considera usar un servicio profesional como SendGrid\")\n",
    "                fallidos += 1\n",
    "                errores_envio += 1\n",
    "                break\n",
    "\n",
    "            # Intentar env√≠o con reconexi√≥n\n",
    "            for intento in range(1, 4):  # 3 intentos\n",
    "                try:\n",
    "                    server.sendmail(remitente, destinatarios, msg.as_string())\n",
    "                    exitosos += 1\n",
    "                    print(f\"‚úÖ ENVIADO (Intento {intento}/3)\")\n",
    "                    print(f\"üì¨ Destinatarios enviados: {destinatarios_enviados}/{limite_destinatarios}\")\n",
    "                    break\n",
    "                except smtplib.SMTPDataError as e:\n",
    "                    if \"Daily user sending limit exceeded\" in str(e):\n",
    "                        print(\"‚õî L√çMITE DIARIO EXCEDIDO\")\n",
    "                        print(\"üí° Por favor usa una cuenta de G Suite o intenta ma√±ana\")\n",
    "                        fallidos += 1\n",
    "                        errores_envio += 1\n",
    "                        # Salir completamente del proceso\n",
    "                        raise\n",
    "                    else:\n",
    "                        if intento < 3:\n",
    "                            print(f\"‚ö†Ô∏è Error en env√≠o. Reintentando... ({str(e)})\")\n",
    "                            time.sleep(5)  # Esperar antes de reintentar\n",
    "                            continue\n",
    "                        else:\n",
    "                            raise\n",
    "                except smtplib.SMTPServerDisconnected:\n",
    "                    if intento < 3:\n",
    "                        print(f\"‚ö†Ô∏è Desconectado. Reconectando... (Intento {intento+1}/3)\")\n",
    "                        server.connect('smtp.gmail.com', 587)\n",
    "                        server.starttls()\n",
    "                        server.login(remitente, password)\n",
    "                        continue\n",
    "                    else:\n",
    "                        raise\n",
    "                except Exception as e:\n",
    "                    if intento < 3:\n",
    "                        print(f\"‚ö†Ô∏è Error en env√≠o. Reintentando... ({str(e)})\")\n",
    "                        time.sleep(5)  # Esperar antes de reintentar\n",
    "                        continue\n",
    "                    else:\n",
    "                        raise\n",
    "\n",
    "            # Pausa para evitar sobrecarga\n",
    "            print(f\"‚è≥ Esperando {pausa_entre_envios} segundos antes del pr√≥ximo env√≠o...\")\n",
    "            time.sleep(pausa_entre_envios)\n",
    "\n",
    "        except smtplib.SMTPDataError as e:\n",
    "            if \"Daily user sending limit exceeded\" in str(e):\n",
    "                print(\"‚õî ERROR CR√çTICO: L√≠mite diario excedido\")\n",
    "                print(\"üõë Deteniendo el proceso de env√≠o\")\n",
    "                fallidos += 1\n",
    "                errores_envio += 1\n",
    "                break\n",
    "            else:\n",
    "                fallidos += 1\n",
    "                errores_envio += 1\n",
    "                print(f\"‚ùå ERROR EN ENV√çO: {str(e)}\")\n",
    "                print(f\"üõ†Ô∏è Detalles t√©cnicos:\\n{traceback.format_exc()}\")\n",
    "        except Exception as e:\n",
    "            fallidos += 1\n",
    "            errores_envio += 1\n",
    "            print(f\"‚ùå ERROR EN ENV√çO: {str(e)}\")\n",
    "            print(f\"üõ†Ô∏è Detalles t√©cnicos:\\n{traceback.format_exc()}\")\n",
    "\n",
    "except Exception as e:\n",
    "    print(f\"‚ùå ERROR CR√çTICO EN EL SISTEMA: {str(e)}\")\n",
    "    print(f\"üõ†Ô∏è Detalles t√©cnicos:\\n{traceback.format_exc()}\")\n",
    "\n",
    "finally:\n",
    "    # Cerrar conexi√≥n SMTP de forma segura\n",
    "    try:\n",
    "        server.quit()\n",
    "        print(\"üîí CONEXI√ìN SMTP CERRADA\")\n",
    "    except:\n",
    "        pass\n",
    "\n",
    "# Reporte final\n",
    "print(\"\\nüìä REPORTE FINAL DE ENV√çOS\")\n",
    "print(f\"‚úÖ CORREOS EXITOSOS: {exitosos}/{len(df_departamento)}\")\n",
    "print(f\"‚ùå CORREOS FALLIDOS: {fallidos}/{len(df_departamento)}\")\n",
    "print(f\"üìé ERRORES DE ARCHIVO: {errores_archivos}\")\n",
    "print(f\"‚úâÔ∏è  ERRORES DE ENV√çO: {errores_envio}\")\n",
    "print(f\"üë§ DESTINATARIOS ENVIADOS: {destinatarios_enviados}/{limite_destinatarios}\")\n",
    "\n",
    "if fallidos == 0 and errores_archivos == 0:\n",
    "    print(\"\\nüéâ ¬°TODOS LOS CORREOS SE ENVIARON EXITOSAMENTE!\")\n",
    "elif fallidos > 0 or errores_archivos > 0:\n",
    "    print(\"\\n‚ö†Ô∏è ALGUNOS CORREOS NO PUDIERON ENVIARSE COMPLETAMENTE\")\n",
    "    print(\"‚ÑπÔ∏è Recomendaciones:\")\n",
    "    print(\"- Verifica los mensajes de error anteriores\")\n",
    "    print(\"- Para correos fallidos, intenta reenviar manualmente\")\n",
    "    print(\"- Verifica la existencia de los archivos PDF en: \" + periodo_folder)\n",
    "    print(\"- Revisa la configuraci√≥n de seguridad de tu cuenta Gmail\")\n",
    "\n",
    "    if \"Daily user sending limit exceeded\" in traceback.format_exc():\n",
    "        print(\"\\nüîî IMPORTANTE: Has excedido el l√≠mite diario de env√≠os de Gmail\")\n",
    "        print(\"üí° Soluciones:\")\n",
    "        print(\"1. Espera 24 horas para que se reinicie tu cuota (se reinicia a medianoche PST)\")\n",
    "        print(\"2. Considera usar un servicio profesional como SendGrid para env√≠os masivos\")\n",
    "        print(\"3. Divide los env√≠os en varios d√≠as\")\n",
    "        print(\"4. Verifica tu actividad de Gmail: https://myaccount.google.com/apppasswords\")"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3",
   "name": "python3"
  },
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}